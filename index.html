<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="不忘初心，方得始终。">
<meta property="og:type" content="website">
<meta property="og:title" content="DenverB">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="DenverB">
<meta property="og:description" content="不忘初心，方得始终。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DenverB">
<meta name="twitter:description" content="不忘初心，方得始终。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>


  <title> DenverB </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">DenverB</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">不忘初心，方得始终。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/02/fork/" itemprop="url">
                  php中的多进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-02T19:52:13+08:00" content="2016-11-02">
              2016-11-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>&#160; &#160; &#160; &#160;看过一个很形象的比喻，一个软件或者程序就像一个大的工厂，进程就像这个工厂里面分工不同的车间（比如焊接车间，锻造车间，包装车间），而进程就像是某个车间里面的工人或者流水线，多个工人或者多条流水线一同工作时就会大大提高效率（<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">参考文章</a>）。所以当我们的程序需要处理大量的事务时，多线程或者多进程就变得十分必要了。  </p>
<h1 id="PHP中的多进程"><a href="#PHP中的多进程" class="headerlink" title="PHP中的多进程"></a>PHP中的多进程</h1><p>&#160; &#160; &#160; &#160;PHP中进程时不支持多线程的，但我们可以使用多进程来代替这个功能，优化我们的程序。首先，PHP中多进程的视线依赖于pcntl和posix两个扩展，可以使用php －m查看是否有这两个扩展。如果没有，可以自行安装。  </p>
<h2 id="开启多进程"><a href="#开启多进程" class="headerlink" title="开启多进程"></a>开启多进程</h2><p>&#160; &#160; &#160; &#160;PHP中的pcntl_fork()函数可以创建一个子进程，当执行完这个函数中，程序就一分为二，一个程序的pid值为0，这个程序就是子进程；另一个程序的pid值大于0（并且等于子进程pid值），这个程序就是父进程我们使用pcntl_wait()函数可以将父进程挂起，知道子进程都推出为止，这样就可以防止僵尸进程的出现。举个例子：  </p>
<pre><code class="php">$parentpid=getmypid();
$pid=pcntl_fork();
<span class="keyword">if</span>($pid===<span class="number">-1</span>){
    <span class="keyword">echo</span> <span class="string">"Fail create"</span>;
}
<span class="keyword">else</span>{
    <span class="keyword">if</span>($pid===<span class="number">0</span>){
        $childpid=getmypid();
        <span class="keyword">echo</span> <span class="string">"This is child PID:"</span>.$childpid;
    }
    <span class="keyword">else</span>{
        <span class="keyword">echo</span> <span class="string">"This is father PID:"</span>.$parentpid.<span class="string">"In this else PID "</span>.$pid.<span class="string">"\n"</span>;
    }
}
pcntl_wait($status);
</code></pre>
<p>&#160; &#160; &#160; &#160;我们运行程序(<strong>注：pcntl_fork()不能在apache上使用，我们可以在CGI模式或者命令行下执行ph</strong>p)可以看到结果：<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-02%20%E4%B8%8B%E5%8D%889.05.03.png" alt=""><br>&#160; &#160; &#160; &#160;可以看到，我们成功创建了一个子进程。后续会再学习如何在进程间相互通信。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/php-PDO/" itemprop="url">
                  PDO机制学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-24T21:19:19+08:00" content="2016-10-24">
              2016-10-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是PDO"><a href="#什么是PDO" class="headerlink" title="什么是PDO"></a>什么是PDO</h2><p>&#160; &#160; &#160; &#160;PDO（PHP数据对象） 是一个轻量级的、具有兼容接口的PHP数据连接拓展，是php官方的一个库，PDO最主要的优点就是不局限于数据库的类型，并且对于做安全开发来说吗，PDO的安全性更加值得信赖。并且在php6中，PDO也成为了默认的与mysql交互的方式。</p>
<h2 id="PDO使用学习记录"><a href="#PDO使用学习记录" class="headerlink" title="PDO使用学习记录"></a>PDO使用学习记录</h2><p>&#160; &#160; &#160; &#160;PDO是php官方的一个库，就可以说就是一个封装好了的类，所以它有很多自己的方法。我们来写一个新的类实现使用PDO机制与mysql交互。那么我们可以在类的__construct()这一魔法函数中进行与mysql数据库的连接。  </p>
<pre><code class="php">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($uname,$passwd,$host,$dbname)</span></span>{
      $dsn = <span class="string">'mysql:dbname='</span>.$dbname.<span class="string">';host='</span>.$host.<span class="string">';charest=utf8'</span>;
      $user = $uname;
      $password = $passwd;
      <span class="keyword">try</span> {
          <span class="keyword">$this</span>-&gt;dbh = <span class="keyword">new</span> PDO($dsn, $user, $password);
      } <span class="keyword">catch</span> (PDOException $e) {
          <span class="keyword">echo</span> <span class="string">'Connection failed: '</span> . $e-&gt;getMessage();
      }
}
</code></pre>
<p>&#160; &#160; &#160; &#160;通过__construct()函数创建了一个数据库连接对象并设置编码为utf－8（注：如果php版本低于5.3.4则不可以在dsn中定义charest，而可以使用<code>$this-&gt;dbh = new PDO($dsn, $user, $password,array(PDO::MYSQL_ATTR_INIT_COMMAND =&gt; &quot;SET NAMES &#39;utf8&#39;;&quot;));</code>来定义编码类型）。之后我们就可以通过$dbh来进行各种数据库操作了。  </p>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><pre><code class="php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">select</span><span class="params">($sql)</span></span>{
        $prepare = <span class="keyword">$this</span>-&gt;dbh-&gt;prepare($sql);
        $prepare-&gt;execute();
        $ret = $prepare-&gt;fetchAll(PDO::FETCH_ASSOC);
        <span class="keyword">return</span> $ret;
  }
</code></pre>
<p>&#160; &#160; &#160; &#160;execute()为执行函数，fecthAll()函数可以获取查询结果，其中的参数是可选的：<br>PDO::FETCH_ASSOC – 关联数组形式<br>PDO::FETCH_NUM – 数字索引数组形式<br>PDO::FETCH_BOTH – 两者数组形式都有<br>PDO::FETCH_OBJ – 按照对象的形式<br>&#160; &#160; &#160; &#160;想要单单返回一列的内容的话，可以使用fechColumn()，该函数的参数为一个整形数字，代表列号。</p>
<h3 id="insert-update"><a href="#insert-update" class="headerlink" title="insert/update"></a>insert/update</h3><pre><code class="php"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dbInsert</span><span class="params">($sql)</span></span>{
    $prepare = <span class="keyword">$this</span>-&gt;dbh;
    $count = $prepare-&gt;exec($sql);
    <span class="keyword">if</span>($count){
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }<span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">false</span>;
    }
}
</code></pre>
<p>&#160; &#160; &#160; &#160;PDO机制中，在执行insert或者update操作时会返回受影响的行数。另外还有两个周边的操作，一个是PDO::lastInsertId()和PDOStatement::rowCount()。PDO::lastInsertId()是返回上次插入操作，主键列类型是自增的最后的自增ID。PDOStatement::rowCount()主要是用于PDO::query()和PDO::prepare()进行DELETE、INSERT、UPDATE操作影响的结果集。</p>
<h2 id="包装成一个类"><a href="#包装成一个类" class="headerlink" title="包装成一个类"></a>包装成一个类</h2><pre><code class="php"><span class="class"><span class="keyword">class</span> <span class="title">MY_PDO</span></span>{
    <span class="keyword">public</span> $dbh;
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($uname,$passwd,$host,$dbname)</span></span>{
        $dsn = <span class="string">'mysql:dbname='</span>.$dbname.<span class="string">';host='</span>.$host.<span class="string">';charest=utf8'</span>;
        $user = $uname;
        $password = $passwd;
        <span class="keyword">try</span> {
            <span class="keyword">$this</span>-&gt;dbh = <span class="keyword">new</span> PDO($dsn, $user, $password,;
        } <span class="keyword">catch</span> (PDOException $e) {
            <span class="keyword">echo</span> <span class="string">'Connection failed: '</span> . $e-&gt;getMessage();
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">SELECT_ALL</span><span class="params">($sql)</span></span>{
        $prepare = <span class="keyword">$this</span>-&gt;dbh-&gt;prepare($sql);
        $prepare-&gt;execute();
        <span class="keyword">return</span> $prepareh-&gt;fetchAll(PDO::FETCH_ASSOC);
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">SELECT_Column</span><span class="params">($sql,$column_num=<span class="number">0</span>)</span></span>{
        $prepare = <span class="keyword">$this</span>-&gt;dbh-&gt;prepare($sql);
        $prepare-&gt;execute();
        $ret = $prepare-&gt;fetchColumn($column_num);
        <span class="keyword">return</span> $ret;
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert_update</span><span class="params">($sql)</span></span>{
        $prepare = <span class="keyword">$this</span>-&gt;dbh;
        $count = $prepare-&gt;exec($sql);
        <span class="keyword">if</span>($count){
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }<span class="keyword">else</span> {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }        
    }
}
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/23/php-compare/" itemprop="url">
                  php中的弱类型比较
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-23T13:40:28+08:00" content="2016-10-23">
              2016-10-23
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于等号"><a href="#关于等号" class="headerlink" title="关于等号"></a>关于等号</h2><p>&#160; &#160; &#160; &#160;在大多数编程语言中，一个等号代表赋值，两个等号代表等于，php也是这样的，但php却还有一个三个等号。三个等号也代表相等，那么两个等号和三个等号之间有什么不同的呢。<br>&#160; &#160; &#160; &#160;在php中，使用两个等号来判断时，只需要两个变量的值相同即可返回true，否则返回false。而使用三个等号，则需要两个变量不仅要值相同，并且两个变量的类型也必须相同时才会返回true，否则返回false。举个简单的例子，a变量为数字1，b变量为字符‘1’，在php中，$a==$b就会返回一个true，而$a===$b就会返回false。那么这就形成了第一种弱类型，<strong>使用两个等号判断变量是否相同时时，只需要变量的值相同，变量类型却没有要求</strong>。  </p>
<h2 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h2><p>&#160; &#160; &#160; &#160;php是一种若类型语言，所以在比较过程中，会对变量进行自动的类型转换。可以看看下面的例子。  </p>
<pre><code class="php"><span class="keyword">echo</span> <span class="string">"0=='':"</span>;
var_dump(<span class="number">0</span>==<span class="string">''</span>);
<span class="keyword">echo</span> <span class="string">"&lt;br&gt;null==false:"</span>;
var_dump(<span class="keyword">null</span>==<span class="keyword">false</span>);
<span class="keyword">echo</span> <span class="string">"&lt;br&gt;1='1abc':"</span>;
var_dump(<span class="number">1</span>==<span class="string">'1abc'</span>);
<span class="keyword">echo</span> <span class="string">"&lt;br&gt;0='abcdefg':"</span>;
var_dump(<span class="number">0</span>==<span class="string">'abcdefg'</span>);
</code></pre>
<p><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-23%20%E4%B8%8B%E5%8D%882.03.50.png" alt=""><br>&#160; &#160; &#160; &#160;可以看到输出结果都为true。可见，php在进行字符串与数字比较时，会强制把字符串转换为数字，而转换时会截取到第一个不是数字的字符前，再见上双等号的缘故。所以1与’1abc’是相等的而0与’abcdefg’是相等的。而且，在php中如果遇到了0e数字的形式会当成科学计数法来处理，所以所有0e数字形式的字符串在进行比较的时候都会被当成0.这也就是在很多ctf中都有出现的“md5碰撞”实质就是两个md5值都是0e数字形式的字符串比较时是相等的。  </p>
<h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><p>&#160; &#160; &#160; &#160;php中有很多存在有弱类型问题的函数。  </p>
<h3 id="md5"><a href="#md5" class="headerlink" title="md5()"></a>md5()</h3><p>&#160; &#160; &#160; &#160;php中可以使用md5函数来加密一个字符串，所以md5函数需要传入一个字符串，但是如果我们给md5函数中传入一个数组，此时md5不会报错，但会返回一个null，此时两个null比较就是相等的了。测试:  </p>
<pre><code class="php">$a=<span class="keyword">array</span>(<span class="string">'abc'</span>,<span class="string">'def'</span>);
$b=<span class="keyword">array</span>(<span class="string">'hij'</span>,<span class="string">'klm'</span>);
$c=<span class="keyword">array</span>(<span class="string">'hhh'</span>=&gt;<span class="string">'aaa'</span>);
var_dump(md5($a)==md5($b));
var_dump(md5($a)==md5($c));
</code></pre>
<p>&#160; &#160; &#160; &#160;运行结果：<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-23%20%E4%B8%8B%E5%8D%882.36.20.png" alt="">  </p>
<h3 id="intval"><a href="#intval" class="headerlink" title="intval()"></a>intval()</h3><p>&#160; &#160; &#160; &#160;intval()函数可以将字符串转化为int，但就像在前面类型转换时所看到的，intval()函数在转换时，也是只截取到第一个不为数字的字符。</p>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p>&#160; &#160; &#160; &#160;strcmp()函数时php中判断字符串是否相等的函数，它实现的方法是通过将需要比较的变量传唤成ascii值，之后相减看结果的正负。如果相等的话，就会返回0，不想等就会返回1或－1。然而当我们将一个参数改为数组，此时，strcmp()不会报错但会返回null，然后null与0在使用两个等号比较时又是相等的，这就会存在一个绕过啦，测试：</p>
<pre><code class="php">$a=<span class="string">'test'</span>;
$b=<span class="keyword">array</span>(<span class="string">'heiheihei'</span>);
var_dump(strcmp($a, $b));
<span class="keyword">if</span>(strcmp($a, $b)==<span class="number">0</span>){
    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;bypass it"</span>;
}
</code></pre>
<p>&#160; &#160; &#160; &#160;运行结果<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-23%20%E4%B8%8B%E5%8D%883.04.20.png" alt="">  </p>
<h3 id="in-array"><a href="#in-array" class="headerlink" title="in_array()"></a>in_array()</h3><p>&#160; &#160; &#160; &#160;in_array()在手册中的定义为：bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] )第一个参数是索要查找的变量，第二个参数是一个目标数组，第三个参数默认为false，如果没有传入第三个参数，则其值为false，也就是说不会要求类型一致。如果传入了一个true，则会寻找数组中与变量值相同且类型一致的元素。换句话说，这个函数实现的方法就是遍历整个数组，然后使用两个等号去对每一个元素和传入的变量进行比较，如果有返回true认为变量在这个数组中是存在的。那么我们这里就存在两个等号比较时会出现的问题，比如说：  </p>
<pre><code class="php">$a=<span class="string">'222test'</span>;
$b=<span class="keyword">array</span>(<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>);
var_dump(in_array($a,$b));
</code></pre>
<p>&#160; &#160; &#160; &#160;运行结果<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-23%20%E4%B8%8B%E5%8D%883.17.41.png" alt=""></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch()"></a>switch()</h3><p>&#160; &#160; &#160; &#160;php中在执行switch($case)语句时，如果case的类型为int，则会对传入的值进行类型转换，那么此时就涉及到前面所说的类型转换问题了。  </p>
<pre><code class="php">$a=<span class="string">'3test'</span>;
<span class="keyword">switch</span> ($a) {
    <span class="keyword">case</span> <span class="number">1</span>:
        <span class="keyword">echo</span> <span class="string">"this is 1"</span>;
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">2</span>:
        <span class="keyword">echo</span> <span class="string">"this is 2"</span>;
        <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">3</span>:
        <span class="keyword">echo</span> <span class="string">"this is 3"</span>;
        <span class="keyword">break</span>;
    <span class="keyword">default</span>:
        <span class="keyword">echo</span> <span class="string">"other"</span>;
        <span class="keyword">break</span>;
}
</code></pre>
<p>&#160; &#160; &#160; &#160;运行结果<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-23%20%E4%B8%8B%E5%8D%883.25.39.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&#160; &#160; &#160; &#160;php是一种弱类型语言，这种弱类型与语言方式虽然会带来一些便捷，但也会存在一些安全问题。所以在进行开发时要尽量避免使用不安全的弱类型比较并对参数进行严格的限制，不要让用户可控的参数直接进入到危险函数中。最后附一张php中弱类型的松散比较表格:<br><img src="http://img0.tuicool.com/AfIVJnE.jpg!web" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/22/sqlmap/" itemprop="url">
                  sqlmap中的“蜜罐”实验
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-22T10:26:39+08:00" content="2016-10-22">
              2016-10-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="记录一次很有意思的小实验"><a href="#记录一次很有意思的小实验" class="headerlink" title="记录一次很有意思的小实验"></a>记录一次很有意思的小实验</h1><p>&#160; &#160; &#160; &#160;前几天在freebuf上看到了一篇很有意思的文章，<a href="http://www.yilan.io/article/5805a294a3dd044f5a2ba81d" target="_blank" rel="external">原文链接</a>，在这篇文章中，作者讲了一个很有意思的事情，我们都知道sqlmap是一个渗透测试的神器，很多人都会使用它来sql注入，但如果没有注意看数据中的内容，就有可能中招。<br>&#160; &#160; &#160; &#160;sqlmap都运行在bash下，而在bash中，有着这样一个小特性，就是当我们输入的内容中含有”`command`“，那么command将会被执行并返回结果。来试一下：<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-22%20%E4%B8%8A%E5%8D%8812.42.08.png" alt=""><br>&#160; &#160; &#160; &#160;从上面一段可以看到ls命令被成功执行了，而在第二条命令中，！！则代表了上一条指令，这也是bash的一个功能，另外，！＋n（数字）则代表之前的第n条指令。<br>&#160; &#160; &#160; &#160;之后我们来想想sqlmap的执行命令，sqlmap中有一个参数–data=”……”,还有一个是–cookie=”……”,他们分别代表了需要post提交的数据和用户的cookie，试想一下，如果我们是网站的开发者，我们就可以在post数据或者cookie中做手脚，我们在其中完全可以插入一条我们想要在攻击者电脑上执行的命令，而如果攻击者没有仔细阅读post数据或者cookie中的内容，而是选择直接复制粘贴的话，那么攻击者就可以被我们攻击了。来做个实验来测试一下。<br>&#160; &#160; &#160; &#160;首先，我们构造一个网站，这个网站可以post提交数据，我们在数据中插入一条nc命令，并让它在后台执行。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-22%20%E4%B8%8A%E5%8D%8810.32.11.png" alt=""><br>&#160; &#160; &#160; &#160;我设置了一个type为hidden的post数据，并给它的value赋值为一条命令，setsid为后台创建一个进程运行，ip地址我的腾讯云服务器，我事先在我的腾讯云开启了1234端口的监听，这样一旦这行命令被执行，就可以诶在我的腾讯云上弹一个shell，进行测试。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-22%20%E4%B8%8A%E5%8D%8810.36.42.png" alt=""><br>&#160; &#160; &#160; &#160;我们在bash中运行sqlmap的命令，并直接将data的数据复制粘贴，可以看到已经在后台运行了nc命令，此时，我的腾讯云商已经获得了攻击者的shell。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-22%20%E4%B8%8A%E5%8D%8810.39.17.png" alt=""><br>&#160; &#160; &#160; &#160;可以看到此时的权限还是root权限，所以可以想干什么干什么。所以呢，在使用sqlmap时还是要看清楚数据的内容，不要攻击不成反被日了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/19/Object-Injection/" itemprop="url">
                  PHP中反序列化引起的安全问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-19T22:51:15+08:00" content="2016-10-19">
              2016-10-19
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="php中的类与序列化"><a href="#php中的类与序列化" class="headerlink" title="php中的类与序列化"></a>php中的类与序列化</h1><p>&#160; &#160; &#160; &#160;和其他面向对象的语言一样，php中也可以通过类的方式来封装一些变量和方法，通过类的定义可以使我们的程序变得更加简洁和方便。而序列化的一大主要用途就是序列化一个类对象，让它变成一个字符串形式，使得数据方便传输和储存，举个例子。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-19%20%E4%B8%8B%E5%8D%8811.45.38.png" alt=""><br>&#160; &#160; &#160; &#160;可以看到，我们可以通过serialize函数讲一个类对象序列化成一个字符串，然后通过unserialize函数讲这个字符串再还原成一个类。这是一个让数据更加方便传输和储存的好方法，但它也可能出现一些不安全的问题。  </p>
<h2 id="php中关于类的魔法函数"><a href="#php中关于类的魔法函数" class="headerlink" title="php中关于类的魔法函数"></a>php中关于类的魔法函数</h2><p>&#160; &#160; &#160; &#160;php的类中有很多魔法函数，他们都以两个下划线开头，例如上面的__construct()，还有比如__wakeup(),__destruct,__set(),__get()等。这些魔法函数会在特定的情况下呗自动调用，完成它们相应的使命。比如说__construct()函数就是在类对象生成时自动被调用，__desstruct()函数就是在类对象销毁时自动被调用。而与序列化相关的两个函数就是__sleep()和__wakeup()函数。我们来看看这两个函数可以做什么。<br>&#160; &#160; &#160; &#160;在上面那幅图中，如果你仔细看看序列化后的内容，你会发现你还是可以看出a，b变量的值的，那如果我希望我序列化后的字符串可以隐藏我不想让别人看到的东西呢。此时，__sleep()函数就可以发挥它的作用，这个函数在执行serialize()时会被自动调用，它需要返回一个你想要隐藏或传递的变量的数组。而与之对应的则是__wakeup()函数，它在unserialize()执行时被调用，它可以再给类中的变量重新赋值或者沿用以前的值。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-20%20%E4%B8%8B%E5%8D%886.34.20.png" alt=""><br>&#160; &#160; &#160; &#160;可以看到，在执行serialize()时，自动调用了__sleep()函数，这个函数需要返回一个数组，经过__sleep()之后序列化的字符串中便不会再泄漏类中变量的内容和名称了，而在unserialize()时，又通过__wakeup()给三个变量重新赋值。  </p>
<h1 id="序列化所带来的问题"><a href="#序列化所带来的问题" class="headerlink" title="序列化所带来的问题"></a>序列化所带来的问题</h1><h2 id="php中的对象注入"><a href="#php中的对象注入" class="headerlink" title="php中的对象注入"></a>php中的对象注入</h2><p>&#160; &#160; &#160; &#160;通过上面可以看到序列化可以把类对象变成一个字符串，之后再经反序列化将这个类对象还原，但是，序列化的字符串一旦由用户可控，那么就会产生一定的安全问题，我们可以看一个例子。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-20%20%E4%B8%8B%E5%8D%887.55.28.png" alt=""><br>&#160; &#160; &#160; &#160;上面这段代码通过获取id的值，进行反序列化。这事正常的情况，但id参数是我们可控的，所以当我们将id参数赋值成一个经序列化后的test类的字符串的话，经过反序列化时，就会生成一个test类的对象。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-20%20%E4%B8%8B%E5%8D%888.00.56.png" alt=""><br>&#160; &#160; &#160; &#160;试想一下，如果test类中会执行eval函数的话，那么就形成了命令执行的漏洞。如下：<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-20%20%E4%B8%8B%E5%8D%888.10.31.png" alt=""><br>&#160; &#160; &#160; &#160;而这样的漏洞在真实情况下也是出现过的<a href="http://www.freebuf.com/vuls/80293.html" target="_blank" rel="external">freebuf上的一篇文章介绍了这个漏洞</a>。<br>&#160; &#160; &#160; &#160;这个问题的解决根本还是控制参数，php手册中也有说过“不要把用户生成的内容传入到unserialize()中”。  </p>
<h2 id="用wechall上的一道题来深入理解一下"><a href="#用wechall上的一道题来深入理解一下" class="headerlink" title="用wechall上的一道题来深入理解一下"></a>用wechall上的一道题来深入理解一下</h2><p>&#160; &#160; &#160; &#160;就是因为看来了wechall上的这道题目才去学习了一下php的对象注入，<a href="http://www.wechall.net/challenge/are_you_serial/index.php" target="_blank" rel="external"></a>，这是一个纯代码审计的问题。给出了好几个源码。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-20%20%E4%B8%8B%E5%8D%8811.06.49.png" alt=""><br>先随便登录一下试试<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-20%20%E4%B8%8B%E5%8D%8811.11.34.png" alt=""><br>提示userlevel为0,gg.<br>其中code.php的部分源码如下:  </p>
<pre><code class="php"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'login'</span>]))
{
        $form-&gt;execute(Common::getPostString(<span class="string">'username'</span>));
}
<span class="keyword">elseif</span> (<span class="keyword">isset</span>($_POST[<span class="string">'logout'</span>]))
{
        $form_logout-&gt;execute();
}

中间代码省略，太多了😂....

<span class="keyword">if</span> (<span class="keyword">false</span> !== ($user = unserialize(Common::getCookie(<span class="string">'serial_user'</span>, <span class="string">''</span>))))
{
        <span class="comment"># Show welcome screen</span>
        <span class="keyword">echo</span> GWF_HTML::message(<span class="string">'Serial Challenger'</span>, $chall-&gt;lang(<span class="string">'msg_wb'</span>, <span class="keyword">array</span>(htmlspecialchars($user-&gt;getUsername()), $user-&gt;getPassword(), $user-&gt;getUserlevel())));
                <span class="comment"># Show logout form</span>
        <span class="keyword">echo</span> $form_logout-&gt;serial_formz()-&gt;templateY($chall-&gt;lang(<span class="string">'ft_logout'</span>));
}
</code></pre>
<p>&#160; &#160; &#160; &#160;可以看到，我们如果post数据中有login，则会调用form对象（另一个文件里定义的一个登录类）中的方法，在这个方法中userlevel变量默认设置成了0，所以gg。所以首先我们post的变量中不能有login或者logout参数，然后我们再继续往下看发现在最后的if判断中从cookie中获取了serial_user变量，而在这时出现了突破口，unserialize()函数，我们进入insecure.inc.php看看  </p>
<pre><code class="php"><span class="meta">&lt;?php</span>
<span class="comment">/**
 * Ultra Safe Auto Include
 * <span class="doctag">@author</span> Z
 * <span class="doctag">@param</span> string $classname
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">my_autoloader</span><span class="params">($classname)</span>
</span>{
        chdir(<span class="string">'challenge/are_you_serial'</span>);
        <span class="keyword">require_once</span> <span class="string">'./'</span>.str_replace(<span class="string">'.'</span>, <span class="string">''</span>, $classname).<span class="string">'.php'</span>;
        chdir(<span class="string">'../../'</span>);
}

<span class="comment">/**
 * Registers auto include
 */</span>
spl_autoload_register(<span class="string">'my_autoloader'</span>);
<span class="meta">?&gt;</span>
</code></pre>
<p>&#160; &#160; &#160; &#160;在这里出现了一个很有意思的函数spl_autoload_register(),去搜了一下<a href="http://www.cnblogs.com/myluke/archive/2011/06/25/2090119.html" target="_blank" rel="external">相关介绍</a>，得知这个函数的作用是将函数注册到spl_autoload中，如果该函数没有被激活，则激活它。那么在这里，我们可以传入一个序列化的字符串，反序列化后，如果我们没有定义这样一个类，那么它将会被传到这里的my_autoload()函数中执行，所以我们需要传入一个类名为SERIAL_Solution的类，这样我们就可以访问到SERIAL_Solution.php了。  </p>
<pre><code class="php"><span class="meta">&lt;?php</span>
<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SERIAL_Solution</span>
</span>{
        <span class="keyword">public</span> $username = <span class="string">''</span>;
        <span class="keyword">public</span> $password = <span class="string">''</span>;        
        <span class="keyword">public</span> $userlevel = <span class="number">0</span>;
}
$a = <span class="keyword">new</span> SERIAL_Solution();
$a-&gt;username=<span class="string">'serial'</span>;
$a-&gt;password=<span class="string">'testtest'</span>;
$a-&gt;userlevel=<span class="number">100</span>;

<span class="keyword">echo</span> serialize($a);
<span class="meta">?&gt;</span>
</code></pre>
<p>&#160; &#160; &#160; &#160;输出为：O:15:”SERIAL_Solution”:3:{s:8:”username”;s:6:”serial”;s:8:”password”;s:8:”testtest”;s:9:”userlevel”;i:100;}<br>&#160; &#160; &#160; &#160;然后我们需要抓包将cookie中的serial_user变量赋值成上面的字符串，然后再将login和logout去掉即可。<br><img src="http://oeix47n80.bkt.clouddn.com/20160319002320256" alt=""><br><img src="http://oeix47n80.bkt.clouddn.com/20160319002329943" alt="">  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&#160; &#160; &#160; &#160;和大多数漏洞一样，反序列化的问题也是用户参数的控制问题引起的，所以好的预防措施就是不要把用户的输入或者是用户可控的参数直接放进反序列化的操作中去。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/13/sql-injection/" itemprop="url">
                  web安全总结－－SQL注入
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-13T22:04:50+08:00" content="2016-10-13">
              2016-10-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h1><p>&#160; &#160; &#160; &#160;SQL注入漏洞一直是为Web安全中最常见也是危险十分大的漏洞。从开学到现在一直在学习SQL注入的相关内容，在这里做一个小结和温习。<br>&#160; &#160; &#160; &#160;SQL注入的学习有很多很好的相关平台，比较常见的是sqli－labs（源码可以在Github 上下载之后进行安装即可），sqlol（这也是一个不错的sql注入的学习平台）等等。。  </p>
<h1 id="SQL注入的产生"><a href="#SQL注入的产生" class="headerlink" title="SQL注入的产生"></a>SQL注入的产生</h1><p>&#160; &#160; &#160; &#160;SQL：结构化查询语言(Structured Query Language)简称SQL是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名。<br>&#160; &#160; &#160; &#160;所有web应用几乎都离不开与数据库的交互，数据成为了web应用的基础，几乎每一个网站背后都拥有着其庞大的数据库，通过获取用户的输入和请求进行数据库的相关操作是web应用中最重要的一部分，而在现实中，总会有想要搞点破坏的用户们，他们的输入可不是为了完成什么请求，而是为了“搞事情”，这也就造成了SQL注入漏洞的产生和利用。</p>
<h1 id="初探SQL注入"><a href="#初探SQL注入" class="headerlink" title="初探SQL注入"></a>初探SQL注入</h1><h2 id="完全相信所有用户"><a href="#完全相信所有用户" class="headerlink" title="完全相信所有用户"></a>完全相信所有用户</h2><p>&#160; &#160; &#160; &#160;先看看一种现在基本不可能出现的情况，就是对用户的输入完全没有进行审查，选择完全相信用户，虽然这种做法真的十分愚蠢，但在web应用刚刚火起来的时候还是十分常见的。在php中我们会使用以下代码来利用用户输入进行数据库的操作：  </p>
<pre><code>$id=$_GET[&apos;id&apos;];
$sql=&quot;SELECT * from test where id=$id&quot;;
$row=mysql_fetch_array(mysql_query($sql));
</code></pre><p>&#160; &#160; &#160; &#160;在这段代码中，用id变量获取了get参数，然后再数据库中进行select查询。然后并没有对与id做任何的审核，这就形成了很大的风险，用户可以通过<a href="http://www.jb51.net/article/20675.htm" target="_blank" rel="external">mysql手注</a>的方式来获取数据库里的一切信息甚至如果权限够的话，还可以直接向服务器内写入一个shell来拿到整个服务器的权限了。<br>获取数据库<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-13%20%E4%B8%8B%E5%8D%8811.18.53.png" alt="data"><br>获取表<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-13%20%E4%B8%8B%E5%8D%8811.15.29.png" alt="data1"></p>
<h2 id="代码写完了，但忘了关报错"><a href="#代码写完了，但忘了关报错" class="headerlink" title="代码写完了，但忘了关报错"></a>代码写完了，但忘了关报错</h2><p>&#160; &#160; &#160; &#160;在开发过程中，php代码的问题并不想其他大多语言那样好调试，因此很多程序员会通过看一些可以显示在网页上的报错信息来获取帮助。但会有粗心的程序员忘记了关掉报错，这也就形成了另一种常见的注入手段报错注入。<br>&#160; &#160; &#160; &#160;报错的信息可以泄漏很多数据库的有关内容，可以通过相关的<a href="http://www.waitalone.cn/mysql-error-based-injection.html" target="_blank" rel="external">报错查询语句</a>来获得数据库内的数据信息。比如当你输入了一些不友好的符号(单引号之类的)服务器返回了报错信息，这时报错语句就可以获得你想要的数据了。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-13%20%E4%B8%8B%E5%8D%8811.22.20.png" alt="data2">  </p>
<h2 id="没有回显，那就盲注吧。"><a href="#没有回显，那就盲注吧。" class="headerlink" title="没有回显，那就盲注吧。"></a>没有回显，那就盲注吧。</h2><p>&#160; &#160; &#160; &#160;上面两种办法都基于服务器给出的回显来获得用户信息。而在很多时候我们从返回页面中并不会发现什么有用的信息。这是或许盲注就可以帮到你了，因为后台在进行数据库操作时，会sql语句之行的返回值来判断是否执行成，来决定是否返回的页面。那么这时，我们就可以利用sql语言中一些很有用的函数来进行盲注，比如说利用if,sleep等函数返回的布尔类型的值决定页面或者页面中的某个元素是否正常返回。<br>&#160; &#160; &#160; &#160;如果手动去盲注的话，需要耗费大量的时间和精力，所以如果sqlmap可以帮到你还是用工具吧，或者自己用python或其他语言写一个脚本来省下时间吧。  </p>
<h1 id="再探SQL注入–编码问题"><a href="#再探SQL注入–编码问题" class="headerlink" title="再探SQL注入–编码问题"></a>再探SQL注入–编码问题</h1><p>&#160; &#160; &#160; &#160;先推荐一篇文章，<a href="http://wiki.ioin.in/post/group/6Rb" target="_blank" rel="external">Phithon大牛推的一篇关于代码审计的文章</a>，相信你看后一定会受益匪浅的  </p>
<h2 id="宽字节绕过"><a href="#宽字节绕过" class="headerlink" title="宽字节绕过"></a>宽字节绕过</h2><p>&#160; &#160; &#160; &#160;现在的web应用基本不太可能出现什么都不过滤的情况了，就算再初级的开发人员也知道在进行数据库查询时，都知道要使用addslashes或者开启全局的gpc（php.ini中设置的magic_quotes_gpc = On）对参数进行一番处理，这两个方法的作用差不多，都是将参数中的单引号等敏感字符进行转义。写个代码来看看它的作用。<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-14%20%E4%B8%8B%E5%8D%8810.47.02.png" alt="data3"><br>&#160; &#160; &#160; &#160;传入一个参数id，值为test’<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-14%20%E4%B8%8B%E5%8D%8810.46.26.png" alt="data4"><br>&#160; &#160; &#160; &#160;我们可以看到test后面的单引号被加上了一个斜杠，斜杠在mysql的查询中代表着转义，也就是单引号失去了原本的意义，也就不能闭合掉mysql查询中的单引号了。这看起来是一个很好的方法，但它存在着一个问题。<br>&#160; &#160; &#160; &#160;当开发者再程序中将mysql的编码方式调成了gbk模式，就会存在一个宽字节绕过的问题。<br>&#160; &#160; &#160; &#160;GBK双字节编码：一个汉字用两个字节表示，首字节对应0x81-0xFE，尾字节对应0x40-0xFE（除0x7F），刚好涵盖了对应的编码0x5C。<br>&#160; &#160; &#160; &#160;0xD5 0x5C 对应了汉字“誠”，于是 %d5%5c  经URL解码后为“誠”。<br>&#160; &#160; &#160; &#160;当我们提交参数 %d5’ ，经浏览器URL编码后为%d5%27，再经PHP URL解码后为 0xd50x27，再经PHP转义后为0xd50x5c0x27，即就是在0x27(‘)之前插入了转义符0x5c（\）。当MySQL采用GBK编码连接时，0xd50x5c0x27 这一字节序列就被MySQL作为GBK编码理解：誠’。<br>&#160; &#160; &#160; &#160;这样就吃掉了PHP的转义符，从而突破了单引号转义的限制。举个例子：<br>&#160; &#160; &#160; &#160;php代码：<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8A%E5%8D%881.49.11.png" alt="data5"><br>&#160; &#160; &#160; &#160;宽字节绕过查询数据库<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8A%E5%8D%881.47.20.png" alt="data6"><br>&#160; &#160; &#160; &#160;对与宽字节的问题来说最好的解决方法是使用有Prepared Statement机制的<a href="http://www.jb51.net/article/24434.htm" target="_blank" rel="external">PDO来进行mysql的查询</a>(在日后的php6种，PDO也将成为默认的mysql执行的方式)。  </p>
<h2 id="其他的编码方式"><a href="#其他的编码方式" class="headerlink" title="其他的编码方式"></a>其他的编码方式</h2><p>&#160; &#160; &#160; &#160;很多web网站的防护都是基于全局gpc的开启或者是使用addslashes来过滤参数，上面说了使用宽字节来绕过的问题，在web应用还有通过其他编码方式进行与数据库的交互而产生的安全问题。  </p>
<h3 id="UrlDecode"><a href="#UrlDecode" class="headerlink" title="UrlDecode"></a>UrlDecode</h3><p>&#160; &#160; &#160; &#160;在web应用中，有时会使用urldecode对get方式收到的参数内容进行转码，但如果在转码后并没有对转码后的内容进行过滤就直接带入数据库的查询语句很有可能会导致urldecode编码绕过的问题。再举个例子。<br>&#160; &#160; &#160; &#160;php代码<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8B%E5%8D%885.16.14.png" alt="data7"><br>&#160; &#160; &#160; &#160;构造查询数据库的POC<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8B%E5%8D%885.19.09.png" alt="data8"><br>&#160; &#160; &#160; &#160;可以看到我们所输入的%25%27再经过urldecode后变成了％27（即单引号），而如果我们没有对urldeocde后的参数内容进行过滤直接带入查询的话，这个单引号就可以闭合前面的单引号了。  </p>
<h3 id="Base64Decode"><a href="#Base64Decode" class="headerlink" title="Base64Decode"></a>Base64Decode</h3><p>&#160; &#160; &#160; &#160;跟上面的urldecode差不多，base64decode绕过的问题同样是因为在对参数进行base64decode后没有再处理就直接带入了数据库的查询，把上面的例子改一改。<br>&#160; &#160; &#160; &#160;php代码<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8B%E5%8D%885.48.02.png" alt="data9"><br>&#160; &#160; &#160; &#160;构造查询数据库的POC<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8B%E5%8D%885.54.13.png" alt="data10">  </p>
<h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><p>&#160; &#160; &#160; &#160;二次注入是一种比较高级的注入方式，现在的web应用对于数据的过滤都比较严格，所以在我们输入数据的时候，一些字符会被过滤或者被转义，所以可能很难进行sql注入，但是有时，因为程序需要，我们会经常将数据库中已有的内容作为参数进行新的数据库操作，那么此时如果对于从数据库中取出的内容没有进行检查就会出现二次注入的问题。用一个例子来说明：<br>&#160; &#160; &#160; &#160;比如说我们在某个应用需要从表中查询用户的信息，使用如下语句：<br>&#160; &#160; &#160; &#160;<code>select * from test where usname=&#39;$name&#39;</code><br>&#160; &#160; &#160; &#160;这里的name变量是我们在数据库存储的用户名，或者直接通过session或者cookie获取的。那么如果我们的用户名储存的是test’ union select database() –+。那么或许我们再执行第一次查询插入数据库是，会被全局gpc或者addslashes函数把单引号转义了。但是需要注意的是，转义只是在执行数据库查询时进行的，数据库里储存的仍然是正常的单引号。验证一下：<br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-15%20%E4%B8%8B%E5%8D%8810.26.38.png" alt="data11"><br>&#160; &#160; &#160; &#160;那么我们的查询语句就会变成了:<br>&#160; &#160; &#160; &#160;<code>select * from test where uname=&#39;test&#39; union select database() --+&#39;</code><br>&#160; &#160; &#160; &#160;这样我们的二次注入就成功了，就可以进行注入了。</p>
<h1 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h1><p>&#160; &#160; &#160; &#160;SQL注入是web应用中十分常见的漏洞，最主要的防护思想就是永远不要相信用户的任何输入。我觉得主要的防护措施要有这么几点：<br>&#160; &#160; &#160; &#160;1.开启全局过滤，对每一个用户可控的参数都进行相应的审查，并且最好使用有Prepared Statement机制的PDO来实现php与mysql的交互。<br>&#160; &#160; &#160; &#160;2.尽量使用白名单政策，无数次的经验教训告诉我们，黑客们异想天开的脑洞总是可以突破各种黑名单的过滤，所以如果在业务允许的情况下尽量使用白名单验证。<br>&#160; &#160; &#160; &#160;3.在web应用中，危险函数＋参数可控是十分优质的入侵条件。所以在开发过程中，尽量不用危险函数，而且要严格控制参数是否由用户可控。  </p>
<h1 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h1><p>&#160; &#160; &#160; &#160;<a href="http://wiki.ioin.in/post/group/6Rb" target="_blank" rel="external">P牛的sec－news上的一篇代码审计文章总结</a><br>&#160; &#160; &#160; &#160;<a href="http://bbs.ichunqiu.com/thread-9518-1-1.html" target="_blank" rel="external">i春秋上关于sql注入的总结文章</a><br>&#160; &#160; &#160; &#160;<a href="http://files.cnblogs.com/files/lcamry/mysql-injection.pdf" target="_blank" rel="external">结合sqli－labs讲解mysql注入</a>  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/04/Test/" itemprop="url">
                  记录这个博客搭建起来的心路历程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-04T17:40:35+08:00" content="2016-10-04">
              2016-10-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用hexo＋Github搭建博客记录"><a href="#使用hexo＋Github搭建博客记录" class="headerlink" title="使用hexo＋Github搭建博客记录"></a>使用hexo＋Github搭建博客记录</h1><p>&#160; &#160; &#160; &#160;十一放假并没有什么正事可以做，尝试着为第一届L－CTF出了签到题，貌似坑了一波参赛选手，好尴尬。。比赛结束后，想着利用假期搭建起自己的博客吧，本来想使用php框架去写的，但感觉太复杂了，于是咨询了一下add dalao，知道了hexo这个东西，于是就看着教程搭建起了这个博客，把搭建过程记录下来吧，也刚好来练习一下Markdown。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>&#160; &#160; &#160; &#160;对于Mac来说，安装hexo需要先安装Xcode，并且由于hexo是一个纯静态的平台，所以还需要安装<a href="http://nodejs.cn/" target="_blank" rel="external">Node</a>,这两个前期准备做好之后，就可以来安装hexo了。<br>&#160; &#160; &#160; &#160;安装完Node后，可以再命令行运行node和npm来检测是否安装成功。</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>  <code>npm install -g hexo-cli --no-optional</code><br>&#160; &#160;这个过程可能有点慢，耐心等待。。</p>
<h3 id="创建hexo目录"><a href="#创建hexo目录" class="headerlink" title="创建hexo目录"></a>创建hexo目录</h3><p>&#160; &#160; &#160; &#160;在任意地方创建一个hexo的文件夹，名字随意。进入该文件夹，执行下列命令。<br>  <code>hexo init</code>  </p>
<p>&#160; &#160;然后执行  </p>
<p>  <code>npm install</code>  </p>
<h2 id="开始搭建属于你的博客"><a href="#开始搭建属于你的博客" class="headerlink" title="开始搭建属于你的博客"></a>开始搭建属于你的博客</h2><p>&#160; &#160; &#160; &#160;在上述所有指令运行完毕后，你的hexo环境就已经完全搭建完成了，下面就可以开始搭建自己的博客了  </p>
<h3 id="创建一篇新的文章"><a href="#创建一篇新的文章" class="headerlink" title="创建一篇新的文章"></a>创建一篇新的文章</h3><p> <code>hexo new &quot;Name&quot;</code>  </p>
<p>&#160; &#160;Name是名字（只是在你的.md文件的名字并不是你真正的博客的名字）</p>
<h3 id="创建一个静态的页面"><a href="#创建一个静态的页面" class="headerlink" title="创建一个静态的页面"></a>创建一个静态的页面</h3><p>  <code>hexo generate</code><br>&#160; &#160;也可以写成<br>  <code>hexo g</code></p>
<h3 id="在本地看看效果"><a href="#在本地看看效果" class="headerlink" title="在本地看看效果"></a>在本地看看效果</h3><p>  <code>hexo sever</code><br>&#160; &#160;也可以写成<br>  <code>hexo s</code><br>&#160; &#160;当看到显示为:<br>  <img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-04%20%E4%B8%8B%E5%8D%888.54.39.png" alt="success"><br>&#160; &#160;这说明已经在在本地4000端口开启了服务，现在可以通过访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 来查看自己的博客了。</p>
<h2 id="把自己的博客放倒Github上去"><a href="#把自己的博客放倒Github上去" class="headerlink" title="把自己的博客放倒Github上去"></a>把自己的博客放倒Github上去</h2><h3 id="注册一个Github并建立一个仓库"><a href="#注册一个Github并建立一个仓库" class="headerlink" title="注册一个Github并建立一个仓库"></a>注册一个Github并建立一个仓库</h3><p>&#160; &#160;首先，你需要有一个Github账户，然后登录账户在右上角的➕处建立一个新的仓库（Nes repository）,仓库名称为 <strong>你的账户名.github.io</strong><br><img src="http://oeix47n80.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-04%20%E4%B8%8B%E5%8D%889.31.40.png" alt="repo"><br>&#160; &#160;创建完成后，你需更改你的hexo文件下的_config.yml文件。在这个文件的最后进行如下修改：   </p>
<pre><code>deploy: 
  type: git 
  repo: https://github.com/用户名/用户名.github.io.git 
  branch: master
</code></pre><p>&#160; &#160;<strong>注:</strong>这个_config.yml是hexo的配置文件，你的博客的很多配置信息都可以在这里面更改，比如主题，博客标题，博客标语之类的。</p>
<h3 id="将自己的博客同步到Github-上去"><a href="#将自己的博客同步到Github-上去" class="headerlink" title="将自己的博客同步到Github 上去"></a>将自己的博客同步到Github 上去</h3><p>&#160; &#160;修改后配置文件后，运行下面的指令（<strong>注：</strong>如果没有初始化git 先运行 git init）<br><code>hexo deploy</code><br>&#160; &#160;也可以写成<br><code>hexo d</code><br>&#160; &#160;看到输出<br><code>INFO  Deploy done: git</code><br>&#160; &#160;说明已经同步完成，这样你的博客就已经搭建完成啦.然后你就可以通过 <a href="https://用户名.github.io" target="_blank" rel="external">https://用户名.github.io</a> 来访问你自己的博客了。</p>
<h2 id="修改博客"><a href="#修改博客" class="headerlink" title="修改博客"></a>修改博客</h2><p>&#160; &#160;每次对自己的博客内容进行修改时，执行以下步骤<br><code>hexo clean</code>  清除当前静态页面<br>&#160; &#160;进行修改<br><code>hexo g</code>  创建新的静态页面<br><code>hexo d</code>  同步到Github</p>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>&#160; &#160;hexo默认的主题是landscape，这个主题是可以自由更换的。你可以从<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">Github上</a>下载你想要的主题放进hexo文件夹里的themes文件夹，之后通过修改_config.yml中的themes来更换你的博客主题样式。</p>
<h3 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h3><p>&#160; &#160;hexo可以扩展安装很多有用的插件,例如:<br>&#160; &#160;RSS订阅功能:<br><code>npm install hexo-generator-feed</code><br>&#160; &#160;Sitemap站长地图:<br><code>npm install hexo-generator-sitemap</code><br>&#160; &#160;还可以通过Disqus评论系统来开启评论功能。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&#160; &#160; &#160; &#160;总的来说，hexo真的是一个很方便而且很容易上手的博客搭建平台，很高兴通过hexo让我的十一长假没有浪费，从现在起，我也要开始自己的博客之旅啦，希望可以以此来督促自己多多学习，多多分享，提高技术水平，不忘初心，方得始终。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oeix47n80.bkt.clouddn.com/IMG_0023.JPG"
               alt="DenverB" />
          <p class="site-author-name" itemprop="name">DenverB</p>
          <p class="site-description motion-element" itemprop="description">不忘初心，方得始终。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DenverB</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  

  

  

  

  


</body>
</html>
